# Инструкция по работе с git
Данная инструкция рассчитана на человека, прежде не работа                       вшего с системами контроля
версий, однако, возможно, имеющего представление о том, чт                       о такое командная строка.
Здесь будут описаны только самые базовые операции, которым                       и необходимо владеть для
успешной работы над научным проектом на Летней школе. 
Если у вас будут возникать какие­либо вопросы — смело обраща                         йтесь к кураторам
проектов за разъяснениями и советами. 
## Краткое введение и терминология 
Системы контроля версий, одной из которых является git, используются при работе с
самыми разными проектами, начиная от программных проектов                     и заканчивая написанием
книги или статьи. При работе с документами мы часто пользуем                         ся командами CTRL+S
*(сохранить)*                      и CTRL+Z *(отменить)*, а если мы хотим сделать несколько вариантов, нам
приходится сохранять каждый из них в отдельный файл, что не в                             сегда удобно. Git же
позволяет делать все то же самое, но не на уровне отдельного ф                                 айла, а на уровне целого
проекта. Каталог с проектом в этом случае называется репози                       торием ***(repository)***. Каждое
такое глобальное CTRL+S называется коммитом                     ***(commit)*** и сохраняет текущую версию
проекта, к которой всегда можно будет вернуться в любой моме                         нт (глобальный CTRL+Z).
Также возможна работа с несколькими версиями, при этом не во                       зникает множества
файлов разных версий (на самом деле все изменения сохраняют                           ся в системной папке .git,
находящейся в корне репозитория, и ее лучше не трогать). Кро                           ме того git позволяет
работать с несколькими копиями репозитория, беря на себя вс                         е проблемы, связанные с
синхронизацией данных. Это не только предохраняет от потер                         и данных, но и делает
возможным эффективную командную работу над проектом. 

### Подготовка 
1. Регистрация на GitHub. GitHub ­ это сервис для хранения репозиториев. Репозиторий научного проекта будет находиться именно там, поэтому если у вас еще нет аккаунта на GitHub, вам необходимо пройти стандартную процедуру регистрации. 
2. Установить git с официального сайта по инструкции: http://git­scm.com/downloads. Возможно, он уже есть у вас в системе — проверьте это, зайдя в командную строку и введя команду git. 
3. Все команды git выполняются в терминале(командной строке). Пользователям Linux/MacOS для этого достаточно запустить Терминал. Пользователям Windows следует использовать утилиту Git Bash либо скачать и распаковать дистрибутив Babun(осторожно, она весит 2Гб — зато полностью эмулирует работу в командной строке Linux). 
4. Настройка git. Нам будет достаточно только задать имя и email командами: <br> git config ­­global user.name "Oleg Yasnev" <br> git config ­­global user.email oyasnev@gmail.com(вы, естественно, подставляете свои имя и email).

## Создание репозитория на GitHub
 Для создания репозитория на GitHub нужно войти в систему, за                         тем в навигационной
панели сверху рядом с вашим именем выбрать "                   +" и "New repository" (или на главной        
странице зеленая кнопка "+ New repository"). Далее заполняем поля:<br> 
*     Repository name: test 
*     Description: Test repository 
*     оставляем выбранным пункт "Public" и проставляем флажок "Initialize this repository with a README".
Нажимаем кнопку "     Create repository". Репозиторий создан! Теперь он доступен по адресу                
https://github.com/oyasnev/test 
Репозиторий, находящийся на GitHub, мы будем называть                       главным. При работе с
научными проектами главный репозиторий уже будет создан руководителями. 

## Базовые операции
1. Создание локальной копии главного репозитория. Для начала нужно перейти в каталог, в котором вы хотите, чтобы появился каталог репозитория, и запустить в нем терминал. Для пользователей Linux/MacOS: запустить Терминал и с помощью команды cd перейти в нужный каталог. Для пользователей Windows: перейти в Проводнике в нужный каталог, щелкнуть правой кнопкой мыши в окне каталога и в контекстном меню выбрать пункт ***"Git Bash"***. После запуска в терминале набрать команду ***git clone*** https://github.com/oyasnev/test В результате в текущем каталоге будет создан подкаталог test, содержащий копию главного репозитория. Для работы с репозиторием необходимо перейти в его каталог командой ***cd test***. 
2. Добавление новых файлов в репозиторий. Давайте создадим в каталоге          репозитория test текстовый файлfirst.txt, содержащий строку текста "Some text". Однако то, что файл появился в каталоге репозитория не означает, что git его уже отслеживает ­ нужно указать это явно командой ***git add*** first.txt.  Теперь наш файл находится под наблюдением git. Давайте сохраним изменения в репозитории и сделаем первый коммит: ***git commit ­m*** "My first commit" Ключ ­m позволяет задать описание коммита. Описание обязательно, иначе коммит не будет выполнен.Теперь давайте создадим каталог ***dir***, а в нем два текстовых файлаa.txt и b.txt. Чтобы при добавлении в git не перечислять их по отдельности,воспользуемся командой git add .которая добавляет в git все новые файлы. И снова сохраним: git commit ­m "dir added"
3. Сохранение изменений файлов. Добавим в файл first.txt еще одну строчку "Some more text" (не забудьте сохранить файл!). И снова закоммитим изменения. Однако если мы воспользуемся известной нам командой ***git commit ­m*** "more text added to first.txt" то мы получим сообщение, что коммитить в общем­то нечего. Почему? Дело в том, что git опять же не знает, какие именно из измененных файлов мы хотим сохранить. Чтобы указать это явно, необходимо воспользоваться описанной выше командой ***git add***. В то же время самый частый сценарий ­ сохранить изменения во всех файлах. Для этих целей в команде ***git commit*** есть ключик ­a.  Итого наша команда будет такой: git commit ­a ­m "more text added to first.txt" Чтобы меньше запоминать, вам будет достаточно для всех коммитов пользоваться командой именно такого вида. Однако помните, что ключ ­a позволяет учесть изменения только в файлах, уже находящихся под наблюдением git. А новые файлы перед коммитом необходимо предварительно явно добавить командой git add(про нее вам рассказали не просто так). 
4. Отправка изменений в главный репозиторий. К этому моменту мы уже немало сделали в нашей локальной копии репозитория, однако если вы обновите веб­страничку с главным репозиторием, вы увидите, что в нем никаких изменений нет. Как их туда внести? Для этого используется команда ***git push***. В процессе выполнения команды от вас потребуется ввести ваш и логин и пароль от аккаунта на ***GitHub***. Когда после успешного завершения команды мы обновим страничку с главным репозиторием, мы увидим, что теперь его содержимое совпадает с нашим локальным репозиторием. 
5. Получение изменений из главного репозитория. Смоделируем ситуацию, в которой нам это пригодится. Для этого откроем еще один терминал в каталоге,отличном от того, в котором лежит наш локальный репозиторий. И создадим еще одну локальную копию главного репозитория (как ­ описано выше). Итого у нас теперь есть два локальных репозитория: первый (старый) и второй (только чтосозданный). Представим, что второй репозиторий на самом деле находится на другом компьютере и с ним работает второй участник. И он решает внести какие­то изменения в файл first.txt (например, добавим туда еще одну строчку текста), находящийся в его локальной копии, т.е. во втором репозитории. Сохраняем файл и коммитим: git commit ­a ­m "more changes in first.txt и отправляем изменения на сервер: git push. Сейчас у нас синхронизированы главный и второй локальный репозитории, но первый локальный отстает. Ему нужно получить изменения из главного репозитория командой ***git pull***. Ура, теперь у нас везде одинаковые версии. 
6. Разрешение конфликтов. В заключение рассмотрим еще один частый сценарий,    распространенный при одновременной работе нескольких человек. Давайте в нашем первом локальном репозитории внесем еще какие­нибудь изменения в файл first.txt, закоммитим и отправим их в главный репозиторий. А затем во втором локальном репозитории создадим файл second.txt и тоже закоммитим. Однако если теперь из второго репозитория мы попробуем сделать ***git push***, то получим ошибку из­за конфликта изменений. Почему? Для простоты можно считать, что при отправке изменений в локальном репозитории должна быть версия, основанная на версии главного репозитория. Тогда как мы во втором репозиории пока ничего не знаем про последний коммит first.txt. Что делать? Сначала нам нужно получить изменения из главного репозитория, затем объединить их с нашими изменениями, и то, что получилось, отправить на главный репозиторий. Звучит непросто, но на самом деле первые два шага сама умеет делать команда ***git pull***. Она достаточно умна, чтобы понять, что в нашем случае надо обновить файл first.txt и добавитьsecond.txt. После чего нам остается просто отправить изменения командой ***git push***. Итого получаем, что при отправке изменений безопасно пользоваться двумя последовательными командами: ***git pull*** (проверить на наличие новых изменений в репозитории и, если                   они есть, выкачать их и объединить с локальными изменениями) ***git push***  (отправить изменения в репозиторий). Таким образом, git умеет разрешать конфликты самостоятельно. Но к сожалению не все. Если бы мы вместо создания second.txt во втором репозитории тоже изменили first.txt, то мы бы имели две измененные версии одного файла и здесь уже git самостоятельно разрешить конфликт не может: нужно вмешательство человека. При грамотно спланированной работе команды, такие ситуации встречаются редко, и мы их рассматривать не будем. Интересующиеся могут посмотреть в интернете или в справке git по команде ***merge*** в разделе "How to resolve conflicts". 

### Итоговая сводка команд 
1. Создание локальной копии главного репозитория: 
    ***git clone*** 
    ***cd test***  (не забыть перейти в каталог репозитория)
2. Добавление новых файлов в репозиторий. Избранные файлы: 
    ***git add*** file1 file2 file3
    Все новые файлы: 
    ***git add*** .
3. Сохранение изменений файлов: 
    ***git commit ­am "commit*** description" 
4. Получение изменений из главного репозитория: 
    ***git pull***
5. Отправка изменений в главный репозиторий (с авторазрешением конфликтов): ***git pull*** (проверить на наличие новых изменений в репозитории и, если    они есть, выкачать их и объединить с локальными изменениями)
    ***git push***  (отправить изменения в репозиторий).

# Основы Git - Работа с удалёнными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков. 

### Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду *git remote*. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум *origin —* имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование. Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию. Если у вас больше одного удалённого репозитория, команда выведет их все.

### Добавление удалённых репозиториев
В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду *git remote add <shortname> <url>*.
Теперь вместо указания полного пути вы можете использовать **pb**. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду *git fetch pb*:

### Получение изменений из удалённого репозитория — Fetch и Pull.
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить: git fetch [remote-name].
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, *git fetch origin* извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда *git fetch* забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки (см. следующий раздел и главу Ветвление в Git чтобы получить больше информации), то вы можете использовать команду *git pull* чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда *git clone* автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение *git pull*, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

### Отправка изменений в удалённый репозиторий (Push)
Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: *git push* <remote-name> <branch-name>. Чтобы отправить вашу ветку *master* на сервер *origin* (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов: ***git push origin master***.

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

### Просмотр удалённого репозитория
Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду ***git remote show <remote>***.
Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните *git pull*, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

### Удаление и переименование удалённых репозиториев
Для переименования удалённого репозитория можно выполнить git remote rename. Например, если вы хотите переименовать *pb* в *paul*, вы можете это сделать при помощи *git remote rename*.
Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как *pb/master*, теперь стало *paul/master*.

Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать *git remote rm*.

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.